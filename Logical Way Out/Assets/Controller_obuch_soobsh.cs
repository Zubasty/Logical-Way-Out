using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class obuch_mes
{
    
    public static string[] perem = new string[8];
    public static void z()
    {
        obuch_mes.perem[0] = "Привет! Эта игра предназначена для обучения азам алгебры логики. Справа сверху ты видишь кнопку для вызова меню. Слева сверху значения всех переменных (кнопок) и функций (дверей). Слева снизу находится кнопка на случай, если захочешь скрыть значения переменных и функций. Справа снизу находится счетчик, показывающий сколько раз ты нажимал на кнопки за уровень. Начнем с самого простого. Нажми на кнопку, открой дверь и перейди на следующий уровень. Подробную информацию по управлению можно посмотреть в меню→справка.";
        obuch_mes.perem[1] = "Отлично! Здесь мы узнаем о такой функции как отрицание. Если функция выглядит как F=x, то когда х=1, F тоже будет равна 1, а вот если функция выглядит как F=¬x, то, когда x=1, F=0 и наоборот. Используя данную информацию, попробуй пройти этот уровень.";
        obuch_mes.perem[2] = "Здесь мы узнаем о такой логической функции, которая читается как И и обозначается симоволом ∧. Для того чтобы результат этой функции был равен 1, значения обеих ее переменных должны быть равны 1.";
        obuch_mes.perem[3] = "Здесь мы узнаем о такой логической функции, которая читается как ИЛИ и обозначается симоволом ∨. Для того чтобы результат этой функции был равен 1, достаточно, чтобы одна из ее переменных принимала значение 1.";
        obuch_mes.perem[4] = "На этом уровне мы узнаем о такой логической функции как эквивалентость, которая обозначается символом ≡. Для того чтобы результат этой функции был равен 1, необходимо, чтобы значения ее переменных были между собой равны (либо оба равны 0, либо оба равны 1).";
        obuch_mes.perem[5] = "На этом уровне мы узнаем о такой логической функции как исключающее или, которая обозначается символом ⊕. Для того, чтобы результат этой функции был равен 1, необходимо, чтобы значения ее переменных были различны (например, 0 и 1 или 1 и 0).";
        obuch_mes.perem[6] = "Здесь мы познакомимся с последней функцией, которую мы еще не изучили. Функция называется импликацией и обозначается символом →. Она равна нулю только в одном единственном случае, когда первая переменная равна 1, а вторая 0 - (1→0=0). Во всех остальных случаях она равна 1.";
        obuch_mes.perem[7] = "Вот и подходит обучение к концу! В последнем уровне будем работать не только с переменными, но и со скобками, которые будут выступать в роли аргументов (например, чтобы функция (x∨y)∧x была равна 1 необходимо, чтобы выражение в скобках было равно 1 и x был равен 1. Пройди этот уровень за 2 нажатия на кнопки и можешь смело отправляться в мир алгебры логики и переходить к тренажеру!";
    }
}
public class Controller_obuch_soobsh : MonoBehaviour
{
    [SerializeField] GameObject Panel;
    [SerializeField] Text Panel_text;

    // Start is called before the first frame update
    void Start()
    {
        int k = SceneManager.GetActiveScene().buildIndex - 4;
        if (k <= 7)
        {
            obuch_mes.z();    
            Panel_text.text = obuch_mes.perem[k];
        }
        else
        {
            Panel.SetActive(false);
        }
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    public void VIKLUCIT_NAHUI_ETU_ZALUPU()
    {
        Panel.SetActive(false);
    }
}
